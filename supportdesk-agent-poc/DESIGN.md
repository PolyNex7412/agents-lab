# MCP 設計・拡張性アドバイス（SupportDesk Agent PoC）

初めて MCP を実装する方向けに、現在の構成の良い点と、拡張しやすくするための設計のコツをまとめます。

---

## 1. 全体像：単一責任と「アプリは MCP クライアント」

### 推奨する役割分担

| 役割 | 担当 | 説明 |
|------|------|------|
| **ナレッジ・ロジックの唯一の実装** | **MCP サーバー** (`mcp-server.mjs`) | FAQ/RAG・Intent・判定・メトリクスはここにだけ書く |
| **ユーザー向け API・UI** | **Web アプリ** (`server.mjs` + フロント) | HTTP を受け、MCP クライアントで MCP サーバーを呼ぶだけ |
| **データ** | `data/*.json` | MCP サーバーからだけ読み書きする（アプリは直接触らない） |

- **メリット**: ロジックの二重実装がなくなる。Cursor/CLI/別アプリからも同じ MCP サーバーを共有できる。
- **拡張時**: 新機能（新ツール・新リソース）は MCP サーバーに追加 → アプリは `callTool` を足すだけ。

---

## 2. MCP サーバー側の拡張性

### 2.1 ツールは「1ツール＝1機能」で細かく分ける

現在: `ask_support`（分類＋RAG＋回答＋判定＋ログ）をひとまとめ。

- **現状のままでも可**: PoC ではこれで十分。
- **拡張しやすくするなら**:
  - `classify_intent` … 意図分類だけ
  - `search_faq` … RAG 検索だけ（topK などパラメータ化）
  - `get_support_answer` … 検索結果＋フォールバックで回答文生成
  - `ask_support` … 上記を組み合わせるオーケストレーション用ツール（既存の挙動を維持）

こうすると、クライアントが「分類だけ」「検索だけ」を呼べるようになり、将来の UI（例: 検索結果を先に出してから回答）や他ツールとの組み合わせがしやすくなります。

### 2.2 Intent を設定で持つ（コードに直書きしない）

```javascript
// 例: data/intents.json で管理
[
  { "id": "account_password", "patterns": ["password", "パスワード", "ログイン", "reset", "リセット"] },
  { "id": "network_vpn", "patterns": ["vpn", "在宅", "リモート", "接続", "つながら"] }
]
```

- `intentAgent()` はこの JSON を読んで正規表現を組み立てる。
- 新しいカテゴリを追加するときは JSON の追加だけで済み、コード変更を減らせます。

### 2.3 リソースは「必要最小限の URI」で登録

現在の `file:///supportdesk/faq.json` のように、実パスを隠して論理 URI で公開するのは良い設計です。

- 追加のナレッジ（例: 手順書 PDF の要約）を足すときは、`registerResource` を追加し、`uri` の命名規則（例: `file:///supportdesk/manuals/{id}`）を決めておくと拡張しやすいです。

### 2.4 エラーハンドリングとログ

- ツール内では `try/catch` で囲み、失敗時は `McpError` や `content: [{ type: "text", text: JSON.stringify({ error: "..." }) }]` で返す。
- ログは現在のように `logs.json` に書くので問題ありません。将来、ログを別システムに送る場合は「MCP サーバー内の 1 関数（例: `appendLog()`）」だけ差し替える形にすると、ツールのコードはほぼそのままで済みます。

---

## 3. アプリ（Express）側の設計

### 3.1 MCP クライアントは「1プロセス1接続」で保持する

- **stdio トランスポート**: MCP サーバーを子プロセスで起動し、stdin/stdout で 1 本の接続を張る。
- 起動時に 1 回だけ `Client` + `StdioClientTransport` で接続し、`/api/ask` や `/api/metrics` ではそのクライアントの `callTool()` を呼ぶ形にすると、プロセス起動オーバーヘッドが減り、実装も単純になります。
- サーバーがクラッシュしたら「次のリクエストで再接続」するフォールバックを用意しておくと安全です。

### 3.2 フォールバック戦略

- **MCP が使えないとき**（子プロセス起動失敗・タイムアウト・未設定など）:
  - 従来の REST 実装（`server.mjs` 内の直接実装）にフォールバックする、または
  - `503 Service Unavailable` と「しばらくして再試行」メッセージを返す
- 本番では「MCP サーバーを別プロセス/別コンテナで動かし、HTTP/SSE トランスポートでつなぐ」構成にすると、アプリと MCP のスケールを独立して変更しやすくなります。

### 3.3 フロントは変えなくてよい

- フロントは引き続き `POST /api/ask` と `GET /api/metrics` を呼ぶだけ。
- 中身が MCP 経由になってもレスポンス形式を合わせれば、フロントの変更は不要です。

---

## 4. 運用・拡張のステップ例

1. **今**: アプリから MCP クライアントで `ask_support` / `get_metrics` を呼ぶ（実装例: `mcp-client.mjs` + `server.mjs` の切り替え）。
2. **次**: MCP サーバーに `search_faq` だけのツールを追加し、UI に「検索結果を先に表示」を足す。
3. **その次**: Intent を `data/intents.json` に外出しし、運用でカテゴリを増やせるようにする。
4. **本番化**: MCP サーバーを HTTP/SSE で公開し、Express はその URL に接続するように変更（SDK の `StreamableHTTPTransport` 等を検討）。

---

## 5. まとめ

- **単一の真実の源**: ビジネスロジックは MCP サーバーに集約し、アプリは「MCP を呼ぶクライアント」に徹する。
- **ツールは小さく・パラメータ化**: 必要になってからでよいが、1 ツール 1 機能にすると拡張しやすい。
- **設定の外部化**: Intent や閾値は JSON/環境変数にすると、コードを触らずにチューニングできる。
- **接続は 1 本・フォールバックあり**: アプリ側は 1 クライアントを保持し、失敗時は再接続または従来実装にフォールバックする。

この方針で進めると、初めての MCP 実装として無理がなく、後からツールやリソースを増やしやすくなります。
